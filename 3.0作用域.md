# 执行上下文与作用域

上下文，程序是分层的。每一次函数调用都会形成一个上下文，在es6中被花括号包裹的内容也会形成一个上下文。

上下文都有一个变量对象，这个对象里面有定义好的变量和函数，这个变量对象会在上下文栈运行里面用到，用于变量标识符的查找。

- 全局上下文，window对象
  - var声明的变量是全局上下文window对象的属性
  - let const 虽然也可以在全局声明，但是他不再是window的属性了

上下文会在执行完毕后会被销毁，包括里面的变量和函数。

这个函数执行时候，这个函数的上下文会被推到上下文栈的顶部，执行完成后会出栈。执行函数上下文时候，在函数里面嵌套的函数上下文会推入栈顶。只有当顶级函数执行完，会销毁，把控制权返还给上一层的上下文

作用域链

- 上下文执行时候会创建，变量对象的一个作用域链。

- 这个作用域链会决定代码的各级上下文访问变量函数的顺序

- 如果上下文的函数，那么活动对象用作变量对象，活动对象只有一个定义变量，arguments

- 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。

  

  [![cDSbFJ.png](https://z3.ax1x.com/2021/04/12/cDSbFJ.png)](https://imgtu.com/i/cDSbFJ)

  **上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数**

## 作用域链增强

- trycatch catch 块

  - 创建一个临时error块，添加到当前作用域链的前端

- with语句

  - bom location对象会添加到作用域链的前端，所以可以访问到Location里面的href值

  ```js
  function buildUrl() {  
  	let qs = "?debug=true";  
  	with(location){  
  		let url = href + qs;  
          return url; 
  	}  
  	
  } 
  ```

  

## 变量声明

- var
  - 在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。
  - 如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，
- let
- const
- 标识符查找
  - 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。**搜索开始于作用域链前端**，以给定的名称搜索对应的标识符。**如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。**（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。